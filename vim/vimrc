scriptencoding utf-8
set encoding=utf-8
set fileformat=unix
set fileformats=unix,dos
set nocompatible
set showmode

" set the runtime path to include Vundle and initialize
set rtp+=~/.vim/bundle/Vundle.vim
call vundle#begin()

Plugin 'VundleVim/Vundle.vim'
Plugin 'scrooloose/nerdTree'
Plugin 'sheerun/vim-polyglot'
Plugin 'dikiaap/minimalist'
Plugin 'qpkorr/vim-bufkill'
Plugin 'tpope/vim-surround'
Plugin 'ap/vim-css-color'
Bundle 'craigemery/vim-autotag'

call vundle#end()            " required
filetype plugin indent on    " required

syntax enable
set t_Co=256
" colorscheme minimalist
filetype indent on
" set autoindent width to 4 spaces (see
" " " http://www.vim.org/tips/tip.php?tip_id=83)
set et
set sw=4
set smarttab
set relativenumber

set ignorecase
set smartcase
"set nowritebackup
set backupcopy=yes

set laststatus=2
set statusline=
set statusline+=%m\ 
set statusline+=\"%F\"\ 
set statusline+=%c,\ %l\/\%L\  
set statusline+=\ chr(%b)
set statusline+=\ [%{&ff=='unix'?'unix':(&ff=='mac'?'mac':'windows')}]
set statusline+=\ [%{&fenc!=''?&fenc:&enc}]
set statusline+=\ %n\ 

let g:jsx_ext_required = 0 " Allow JSX in normal JS files

if version >= 700
  hi StatusLine term=bold,reverse ctermbg=Green gui=undercurl guisp=Green
  hi StatusLineNC term=reverse ctermbg=White gui=undercurl guisp=Black
  au InsertEnter * hi StatusLine term=bold,reverse ctermbg=Green gui=undercurl guisp=Green
endif

autocmd FileType .scss setlocal formatoptions-=c formatoptions-=r formatoptions-=o

" Remap the leader to <Space>
let mapleader="\<Space>"

" Save all buffers
nnoremap <leader>w :wa<cr>

" autoclose tags
inoremap ( ()<Left>
inoremap { {}<Left>
inoremap [ []<Left>
inoremap " ""<Left>
inoremap ' ''<Left>
inoremap ` ``<Left>
inoremap <<< <<<EOT<cr>EOT;<ESC>O<ESC>
inoremap '<pre echo '<pre>' . print_r(, true) . '</pre>';<ESC>F,<Ins>
inoremap <p> <p></p><ESC>F<
inoremap <code> <code></code><ESC>F<
inoremap <section> <section></section><ESC>F<
inoremap <aside> <aside></aside><ESC>F<
inoremap <header> <header></header><ESC>F<
inoremap <ul> <ul><cr></ul><ESC>O<ESC>
inoremap <li> <li></li><ESC>F<
inoremap <table> <table><cr></table><ESC>O<ESC>
inoremap <thead> <thead><cr></thead><ESC>O<ESC>
inoremap <tbody> <tbody><cr></tbody><ESC>O<ESC>
inoremap <tr> <tr><cr></tr><ESC>O<ESC>
inoremap <th> <th></th><ESC>F<
inoremap <td> <td></td><ESC>F<
inoremap <a <a href=""></a><ESC>F<
inoremap _blank target="_blank"<ESC>

"move lines around
nnoremap <leader>k :m-2<cr>==
nnoremap <leader>j :m+<cr>==
xnoremap <leader>k :m-2<cr>gv=gv
xnoremap <leader>j :m'>+<cr>gv=gv"

map <C-n> :NERDTreeToggle<CR>

nnoremap <A-A> <C-a>
nnoremap <A-x> <C-x>

nmap    j       gj
nmap    k       gk

map     <F12>   :nohlsearch<CR>
imap    <F12>   <ESC>:nohlsearch<CR>i
vmap    <F12>   <ESC>:nohlsearch<CR>gv

"Split window mappings
map <Leader><Leader> <ESC>:vsplit<CR>:wincmd l<cr>
map <Leader>/   <ESC>:split<CR>:wincmd j<CR>
nnoremap <silent> <C-h> :call WinMove('h')<cr>
nnoremap <silent> <C-j> :call WinMove('j')<cr>
nnoremap <silent> <C-k> :call WinMove('k')<cr>
nnoremap <silent> <C-l> :call WinMove('l')<cr>))))

function! WinMove(key)
  let t:curwin = winnr()
  exec "wincmd ".a:key
  if (t:curwin == winnr())
    if (match(a:key,'[jk]'))
      wincmd v
    else
      wincmd s
    endif
    exec "wincmd ".a:key
  endif
endfunction

"Buffer mappings
map <F6> :buffers<CR>
map     <C-LEFT>  <ESC>:bp<CR>
map     <C-RIGHT> <ESC>:bn<CR>
map     <Leader>1 <ESC>:b1<CR>
map     <Leader>2 <ESC>:b2<CR>
map     <Leader>3 <ESC>:b3<CR>
map     <Leader>4 <ESC>:b4<CR>
map     <Leader>5 <ESC>:b5<CR>
map     <Leader>6 <ESC>:b6<CR>
map     <Leader>7 <ESC>:b7<CR>
map     <Leader>8 <ESC>:b8<CR>
map     <Leader>9 <ESC>:b9<CR>

"Other F keys
map <F3> :!ls<CR>
map <F4> :!pwd<CR>
map <F5> :so $MYVIMRC<CR>

map <Leader>wli ^i<li><Esc>$a</li><Esc>j

map <Leader>wa ^i<a href=""><Esc>$a</a><Esc>j
map <Leader>wwa bi<a href=""><Esc>ea</a><Esc>
map <Leader>wp ^i<p><Esc>$a</p><Esc>j
map <Leader>wb ^i<strong><Esc>$a</strong><Esc>j
map <Leader>wtr ^i<tr><Esc>$a</tr><Esc>j
map <Leader>wtd ^i<td><Esc>$a</td><Esc>j
map <Leader>wth ^i<th><Esc>$a</th><Esc>j
map <Leader>wh1 ^i<h1><Esc>$a</h1><Esc>j
map <Leader>wh2 ^i<h2><Esc>$a</h2><Esc>j
map <Leader>wh3 ^i<h3><Esc>$a</h3><Esc>j
map <Leader>wh4 ^i<h4><Esc>$a</h4><Esc>j
map <Leader>wi ^i<em><Esc>$a</em><Esc>j
map <Leader>wb ^i<strong><Esc>$a</strong><Esc>j
map <Leader>wdt ^i<dt><Esc>$a</dt><Esc>j
map <Leader>wdd ^i<dd><Esc>$a</dd><Esc>j
map <Leader>w_( ^i<?=_("<Esc>$a")?><Esc>
map <Leader>w" ^i"<Esc>$a"<Esc>j
map <Leader>/* ^i/*<Esc>$a<Esc>$a*/

nnoremap <leader>ev <C-w><C-v><C-l>:e $MYVIMRC<cr>

if has("multi_byte")    " if not, we need to recompile
  if &enc !~? '^u'      " if the locale 'encoding' starts with u or U
                        " then Unicode is already set
    if &tenc == ''
      let &tenc = &enc  " save the keyboard charset
    endif
    set enc=utf-8       " to support Unicode fully, we need to be able
                        " to represent all Unicode codepoints in memory
  endif
  set fencs=ucs-bom,utf-8,latin1
  setg bomb             " default for new Unicode files
  setg fenc=latin1      " default for files created from scratch
  set encoding=utf8
else
  echomsg 'Warning: Multibyte support is not compiled-in.'
endif
